<html> 
	<div class="container">
  		<img src="https://raw.githubusercontent.com/TheCrystalKeeper/final-project/main/thefinalproject.png" alt="Terrific Terrains">
	</div>
	<head>
		<script type="text/javascript" id="MathJax-script" async
  			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
		</script>
		<script>
  			MathJax = {
    				tex: {
      					inlineMath: [['$', '$']]
    				}
  			};
		</script>
 		<Title>CS 184 Final Project Milestone</Title>
 		<link rel="stylesheet" href="styling.css">
		
		<style>
		a:link, a:visited {
		  /* background-color: #17191A; */
		  color: #84b8eb;
		  /* padding: 14px 25px; */
		  /* text-align: center; */
		  text-decoration: none;
		  /* display: inline-block; */
		}
		
		a:hover, a:active {
		  /* background-color: white; */
		  text-decoration: underline;
		}

		h4 {
			color: #84b8eb;
		}
		</style>

	</head>
	<body>
		<h2>Terrain Generation</h2>
		<!-- <h2>Robust Particle Simulator - Milestone</b></h2>-->
		<center>
		<h4 style="color: #17191A">By the Preposterous Particles:</h4>
		<h5 style="color: #17191A">Jaron Erba, Jennifer Zhao, Sriram Srivatsan, and Lili Wang</h5>
		</center>
		<br>

		<h3>Abstract</h3>

		<p stye="width: 100%">
			Many popular games utilize aspects of terrain generation to create a realistic, yet non-deterministic, experience. The most prominent example of such a game is Minecraft, where a procedural generation script is run upon creation of a game instance, dynamically updating the terrain as more of the world is explored. Similarly, other games like No Man's Sky use algorithms like Marching Cubes and the Transvoxel Algorithm in order to make the world look more realistic while also minimizing computational and storage overhead. In this project, we implemented multiple popular terrain generation algorithms such as 2D and 3D Perlin Noise and Marching Cubes, incorporating our own ideas in order to adapt the generation to make unique and interesting scenes. In addition, we developed a particle system to interact with the intricacies of the terrain, offering a more immersive and dynamic experience.
		</p>

		<h3>Technical Approach</h3>

		<h4>Unity, Blender, and Sources</h4>

		<p stye="width: 100%">
			Due to the overhead of creating our own rendering application or building from a CS 184 project implementation, we decided to use Unity in order to help with rendering our objects and having datastructures we could modify. To ensure that we did a substantial amount of work, we limited ourselves to only using Unity to render, and we coded all GameObjects, algorithms, assets, GPU accelerations, and shaders by ourselves. Unfortunately, learning Unity was probably half of the work in this project, since there was a lot of documentation to read and videos to watch before we could even start with the coding. We also used Blender to model trees and leaves, which we used as surface objects in order to make our terrain more realistic. We made these assets ourselves, without downloading or using any already existing models. Finally, we referenced many articles and videos throughout our implementation. We did not borrow any code except for a list of all possible marching cubes configurations which is a static table, but we used many ideas which are cited at the bottom of this page. 
		</p>

		<h4>2D Perlin Noise</h4>

		<p stye="width: 100%">
			Our first goal was to make a realistic procedurally generated surface. To make this surface, first we made a mesh of vertices, each with an $x$ and $z$ position where $-\frac{s}{2} \leq x, z \leq \frac{s}{2}$, where $s$ is the size of the grid. There are $n x n$ total vertices where $\frac{n}{s}$ is the resolution of the mesh. To create mountains and valleys and other dynamic objects, we then sampled the $Mathf.PerlinNoise$ function on each vertex's coordinate to get a $y$-value associated with it. The resulting terrain is shown below:

		</p>

		<p stye="width: 100%">
			We even added a scroll feature that allowed us to maneuver around the terrain, since Perlin noise is continuous and deterministic upon its input:
			
		</p>
		
		<p stye="width: 100%">
			Unfortunately, this was not enough, since the $y$-values could be in $[0, 1]$, a
			
		</p>
		
		<h4>3D Perlin Noise</h4>

		<h4>Marching cubes</h4>

		<p>
			The base of each terrain is generated using the Marching Cubes Algorithm. Marching Cubes iterates through each voxel of a 3D grid in space. Each voxel is a cube that is adjacent to 8 vertices. Each vertex is determined to be within or above the surface of the terrain based on a threshold value. Finally, <a href="https://paulbourke.net/geometry/polygonise/">a lookup table</a> is referenced to determine which edges on the cube are necessary for the resulting mesh. These edges are stored as vertices and triangles, which Unity processes into an object mesh.
		</p>
		
		<br>
		<center>
			<img src="images/voxels.png" alt="Voxels" style="width: 50%">
			<br>
			<p>Possible Triangle Configurations for a Single Voxel.</p>
		</center>
		<br>
		
		<p>
			For a realistically random distribution of configurations, we used the 3D Perlin Noise Function to assign an isovalue to each vertex. The isolevel threshold is 0.5, as is standard.
		</p>

		<h4>Particle Simulation</h4>

		<p>
			For the particle system, we created a particle class with attributes such as position, velocity, and radius. The particles are initialized with a random position above the terrain and added to a list of particles. Each particle starts with a downward velocity due to gravity and the particle position is updated by adding the current velocity multiplied by time elapsed. We used the terrain vertices to determine when the particle collided with the terrain by finding the highest point on the terrain below the particle. Upon collision with the terrain, we bounced the particle off the ground by flipping the velocity in the y direction, multiplied by a certain damping factor. 
		</p>
		<p>
			We defined particle collisions using each particleâ€™s position and radius. We checked the distance between each particle and moved the particles in a random direction to the side if the particles were touching to simulate elastic collisions between the particles. We attempted to use terrain tangent vectors to calculate changes in direction due to collisions but we were not able to complete this in time. 
		</p>
		<p>
			We added the particles to Unity by creating a list of prefabs which are located at the positions defined by the particles in the particles list. We modeled objects such as petals and hail in Blender and imported them into Unity, using the models as the object for the prefab. 
		</p>

		<h3>Challenges & Lessons Learned</h3>

		<h3>Results</h3>

		<h3>References</h3>

		<h4>Unity</h4>

		<p>
			<ul style="color: #17191A">
				<li>
					<a href="https://docs.unity3d.com/Manual/index.html">https://docs.unity3d.com/Manual/index.html</a>
				</li>
				<li>
					<a href="https://forum.unity.com/">https://forum.unity.com/</a>
				</li>
				<!-- <li>
					<a href="https://learn.unity.com/tutorial/creating-a-new-project">https://learn.unity.com/tutorial/creating-a-new-project</a>
				</li>
				<li>
					<a href="https://learn.unity.com/tutorial/unity-interface-overview">https://learn.unity.com/tutorial/unity-interface-overview</a>
				</li> -->
			</ul>

		<h4>Particle Simulation</h4>

		<p>
			<ul style="color: #17191A">
				<li>
					<a href="https://fvcaputo.github.io/2016/01/11/sand-particle-system-in-unity.html">https://fvcaputo.github.io/2016/01/11/sand-particle-system-in-unity.html</a>
				</li>
				<li>
					<a href="https://teaching.smp.uq.edu.au/scims/Adv_calculus/Velocity_field.html">https://teaching.smp.uq.edu.au/scims/Adv_calculus/Velocity_field.html</a>
				</li>
				<li>
					<a href="https://en.wikipedia.org/wiki/Lattice_Boltzmann_methods">https://en.wikipedia.org/wiki/Lattice_Boltzmann_methods</a>
				</li>
			</ul>
		</p>

		<h4>Marching Cubes</h4>

		<p>
			<ul style="color: #17191A">
				<li>
					<a href="https://groups.csail.mit.edu/graphics/classes/6.838/S98/meetings/m7/voxels.html">https://groups.csail.mit.edu/graphics/classes/6.838/S98/meetings/m7/voxels.html</a>
				</li>
				<li>
					<a href="https://paulbourke.net/geometry/polygonise/">https://paulbourke.net/geometry/polygonise/</a>
				</li>
				<li>
					<a href="https://en.wikipedia.org/wiki/Marching_cubes">https://en.wikipedia.org/wiki/Marching_cubes</a>
				</li>
				<li>
					<a href="https://www.youtube.com/watch?v=M3iI2l0ltbE">https://www.youtube.com/watch?v=M3iI2l0ltbE</a>
				</li>
				<li>
					<a href="https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-1-generating-complex-procedural-terrains-using-gpu">https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-1-generating-complex-procedural-terrains-using-gpu</a>
				</li>
				<li>
					<a href="https://fileadmin.cs.lth.se/cs/Education/EDAN35/projects/20FilipMathias_MCTerrain.pdf">https://fileadmin.cs.lth.se/cs/Education/EDAN35/projects/20FilipMathias_MCTerrain.pdf</a>
				</li>

			</ul>

		<h3>Constributions from Each Team Member</h3>

		<p>
			<ul style="color: #17191A">
				<li>Jaron Erba: </li>
				<li>Jennifer Zhao: </li>
				<li>Sriram Srivatsan: </li>
				<li>Lili Wang: </li>
		</p>

		<!--<h3 style="color: #4889ca"><b>Progress</b></h3>
        <p style="color: #17191A; width: 100%">
			After a bit of discussion, we decided to use Unity as tool for basic mechanics such as object rendering. This is so that we do not have the overhead of building a renderer from scratch. To do this we have been  learning how to use Unity. Although we are using Unity to do some basic operations, we are limiting ourselves to using Unity to only render scenes and create primitives. We are still building our own collision detection and particle movement simulator. 
		</p>

        <p style="color: #17191A; width: 100%">
			In terms of deliverables, we are a little bit behind in our original plan. By this week, we planned to have both particle simulation and wind simulation done, but we have only finished wind simulation. We are researching how to model our particles and most efficiently calculate the forces acting on each particle. We are confident that we will be able to do particle simulation now that we have figured out how to use Unity. As for wind simulation, we are able to accurately model the pattern of wind with respected to other objects in the scene. Next is to make this wind be a force that influences particles in the scene.
		</p>
        
        <br>
        <h3 style="color: #4889ca"><b>New Schedule</b></h3>
		<h4 style="color: #84b8eb"><b>Week 1 4/1 - 4/7</b></h4>
		<p style="color: #17191A; width: 100%">We spent this week figuring out how to use Unity. Most of this time was spent reading documentation and figuring out how to use scripts.
		</p>
		<h4 style="color: #84b8eb"><b>Week 2 4/8 - 4/14</b></h4>
		<p style="color: #17191A; width: 100%">We spent this time creating a wind simulation. First we started with wind represented as cubes. Then, we added forces to this wind. Finally, we made the wind move around based on collisions with primitives and other wind particles in the scene.
		</p>
		<h4 style="color: #84b8eb"><b>Week 3 4/15 - 4/21</b></h4>
		<p style="color: #17191A; width: 100%">We will spend this portion of time coding up our various particle representations as well as forces related to simulating these particles in real time. This week we will focus on making the simulations physically accurate. 
		</p>
		<h4 style="color: #84b8eb"><b>Week 4 4/22 - 4/28</b></h4>
		<p style="color: #17191A; width: 100%">We will spend this portion of time coding up particle representations and forces so we can simulate these particles in real time. This week we will focus on making the simulations faster, with acceleration structures, hardware manipulation, and code optimization.
		</p>
		<h4 style="color: #84b8eb"><b>Tuesday, April 30</b></h4>
		<p style="color: #17191A; width: 100%">Final Project Due</p>
		<br><br>

		<a href="https://www.youtube.com/watch?v=1XRoO1C7U64">Project Milestone Video</a>
		<br>
		<br>
		<a href="https://docs.google.com/presentation/d/14ptKYa0AihhWREvRuuecXLMB9_yRW9wVIqEGc3Z_Zh0/edit#slide=id.g2cd11bda039_0_51<">Project Milestone Presentation Slides</a>
		<br>
		<br>
		<a href="https://thecrystalkeeper.github.io/final-project/index.html">Project Proposal</a> -->
	</body>
<!-- 	<script>
		var links = document.body.getElementsByTagName("a")
		var a = window.location.href.indexOf(".io")
		var repo_name = window.location.href.substring(a+3)
		for(var i = 0; i < links.length; i++){
			var link = links[i]
			var actual_name = link.href.substring(link.href.indexOf(".io")+4)
			link.href = repo_name + actual_name
		}
	</script> -->
</html>
